"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const rx_stomp_1 = require("@stomp/rx-stomp");
const stompjs_1 = require("@stomp/stompjs");
const axios_1 = require("axios");
const base_64_1 = require("base-64");
const operators_1 = require("rxjs/operators");
const uuid_1 = require("uuid");
const version_1 = require("../environment/version");
let TransportFallback;
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
const transportFallbackPromise = Promise.resolve().then(() => require('sockjs-client/dist/sockjs.js')).then((sockjs) => {
    TransportFallback = sockjs.default;
})
    .catch((error) => {
    ErrorMessageTransportFallback.errorMessage = error.message;
    TransportFallback = ErrorMessageTransportFallback;
});
class ErrorMessageTransportFallback {
    constructor() {
        throw new Error('Encountered error when attempting to use transport fallback: ' +
            ErrorMessageTransportFallback.errorMessage);
    }
}
class StompX {
    constructor(configuration) {
        this.topics = new Map();
        this.pendingActions = new Map();
        this.pendingRelayErrors = new Map();
        this.pendingActionErrors = new Map();
        this.eventHandlers = new Map();
        this.rxStomp = new rx_stomp_1.RxStomp();
        this.initialized = false;
        this.host = configuration.host;
        if (configuration.isSecure) {
            this.wsScheme = 'wss';
            this.httpScheme = 'https';
        }
        else {
            this.wsScheme = 'ws';
            this.httpScheme = 'http';
        }
        this.rxStompConfig = {
            stompVersions: new stompjs_1.Versions(['1.2']),
            connectionTimeout: 60000,
            heartbeatIncoming: 10000,
            heartbeatOutgoing: 60000,
            debug: (message) => {
                if (configuration.isDebug) {
                    console.log('StompX Debug:\n' + message);
                }
            },
        };
        if (typeof navigator != 'undefined' && navigator.product == 'ReactNative') {
            this.rxStompConfig.forceBinaryWSFrames = true;
            this.rxStompConfig.appendMissingNULLonIncoming = true;
        }
        this.axios = axios_1.default.create({
            baseURL: this.httpScheme + '://' + this.host,
        });
    }
    connect(request) {
        const host = this.host;
        const connectHeaders = {
            'StompX-User': request.username,
            'StompX-User-Agent': `ChatKitty-JS-Core/${version_1.version}`,
        };
        if (request.authParams) {
            connectHeaders['StompX-Auth-Params'] = (0, base_64_1.encode)(JSON.stringify(request.authParams));
        }
        if (typeof WebSocket === 'function') {
            this.rxStompConfig.brokerURL = `${this.wsScheme}://${host}/rtm/websocket?api-key=${encodeURIComponent(request.apiKey)}`;
        }
        else {
            this.rxStompConfig.webSocketFactory = () => {
                return new TransportFallback(`${this.httpScheme}://${host}/rtm?api-key=${encodeURIComponent(request.apiKey)}`);
            };
        }
        this.rxStomp.configure(Object.assign(Object.assign({}, this.rxStompConfig), { connectHeaders }));
        this.rxStomp.serverHeaders$.subscribe((headers) => {
            this.rxStomp.configure(Object.assign(Object.assign({}, this.rxStompConfig), { connectHeaders: Object.assign(Object.assign({}, connectHeaders), { 'StompX-Auth-Session-ID': headers['session'] }) }));
        });
        this.rxStomp.connected$.subscribe(() => {
            this.relayResource({
                destination: '/application/v1/user.relay',
                onSuccess: (user) => {
                    if (this.initialized) {
                        request.onConnected(user);
                    }
                    else {
                        this.rxStomp
                            .watch('/user/queue/v1/errors', {
                            id: StompX.generateSubscriptionId(),
                        })
                            .subscribe((message) => {
                            const error = JSON.parse(message.body);
                            const subscription = message.headers['subscription-id'];
                            const receipt = message.headers['receipt-id'];
                            if (subscription) {
                                const handler = this.pendingRelayErrors.get(subscription);
                                if (handler) {
                                    handler(error);
                                    this.pendingRelayErrors.delete(subscription);
                                }
                            }
                            if (receipt) {
                                const handler = this.pendingActionErrors.get(receipt);
                                if (handler) {
                                    handler(error);
                                    this.pendingActionErrors.delete(receipt);
                                }
                            }
                            if (!subscription && !receipt) {
                                this.pendingActionErrors.forEach((handler) => {
                                    handler(error);
                                });
                                this.pendingActionErrors.clear();
                            }
                        });
                        this.relayResource({
                            destination: '/application/v1/user.write_file_access_grant.relay',
                            onSuccess: (write) => {
                                this.relayResource({
                                    destination: '/application/v1/user.read_file_access_grant.relay',
                                    onSuccess: (read) => {
                                        request.onSuccess(user, write.grant, read.grant);
                                        request.onConnected(user);
                                        this.initialized = true;
                                    },
                                });
                            },
                        });
                    }
                },
            });
        });
        this.rxStomp.connectionState$.subscribe((state) => {
            if (state == rx_stomp_1.RxStompState.CLOSED) {
                request.onConnectionLost();
            }
            if (state == rx_stomp_1.RxStompState.OPEN) {
                request.onConnectionResumed();
            }
        });
        this.rxStomp.stompErrors$.subscribe((frame) => {
            let error;
            try {
                error = JSON.parse(frame.body);
            }
            catch (e) {
                error = {
                    error: 'UnknownChatKittyError',
                    message: 'An unknown error occurred.',
                    timestamp: new Date().toISOString(),
                };
            }
            if (error.error == 'AccessDeniedError') {
                const onResult = () => request.onError(error);
                this.disconnect().then(onResult, onResult);
            }
            else {
                request.onError(error);
            }
        });
        this.rxStomp.webSocketErrors$.subscribe((error) => {
            console.error(error);
            request.onError({
                error: 'ChatKittyConnectionError',
                message: 'Could not connect to ChatKitty',
                timestamp: new Date().toISOString(),
            });
        });
        transportFallbackPromise.then(() => {
            this.rxStomp.activate();
        });
    }
    relayResource(request) {
        this.guardConnected(() => {
            const subscriptionId = StompX.generateSubscriptionId();
            if (request.onError) {
                this.pendingRelayErrors.set(subscriptionId, request.onError);
            }
            this.rxStomp.stompClient.subscribe(request.destination, (message) => {
                request.onSuccess(JSON.parse(message.body).resource);
            }, Object.assign(Object.assign({}, request.parameters), { id: subscriptionId }));
        });
    }
    listenToTopic(request) {
        let unsubscribe = () => {
            // Do nothing
        };
        this.guardConnected(() => {
            const subscriptionReceipt = StompX.generateReceipt();
            const onSuccess = request.onSuccess;
            if (onSuccess) {
                this.rxStomp.watchForReceipt(subscriptionReceipt, () => {
                    onSuccess();
                });
            }
            const subscription = this.rxStomp
                .watch(request.topic, {
                id: StompX.generateSubscriptionId(),
                receipt: subscriptionReceipt,
                ack: 'client-individual',
            })
                .subscribe((message) => {
                const event = JSON.parse(message.body);
                const receipt = message.headers['receipt-id'];
                if (receipt) {
                    const action = this.pendingActions.get(receipt);
                    if (action &&
                        (!action.types ||
                            action.types.find((type) => type === event.type))) {
                        action.action(event.resource);
                        this.pendingActions.delete(receipt);
                    }
                }
                const handlers = this.eventHandlers.get(request.topic);
                if (handlers) {
                    handlers.forEach((handler) => {
                        if (handler.event === event.type) {
                            handler.onSuccess(event.resource);
                        }
                    });
                }
                message.ack();
            });
            this.topics.set(request.topic, subscription);
            unsubscribe = () => {
                subscription.unsubscribe();
                this.topics.delete(request.topic);
            };
        });
        return () => unsubscribe();
    }
    listenForEvent(request) {
        let handlers = this.eventHandlers.get(request.topic);
        if (handlers === undefined) {
            handlers = new Set();
        }
        const handler = {
            event: request.event,
            onSuccess: request.onSuccess,
        };
        handlers.add(handler);
        this.eventHandlers.set(request.topic, handlers);
        return () => {
            if (handlers) {
                handlers.delete(handler);
            }
        };
    }
    sendAction(request) {
        this.guardConnected(() => {
            const receipt = StompX.generateReceipt();
            if (request.onSent) {
                this.rxStomp.watchForReceipt(receipt, request.onSent);
            }
            if (request.onSuccess) {
                this.pendingActions.set(receipt, {
                    types: request.events,
                    action: request.onSuccess,
                });
            }
            if (request.onError) {
                this.pendingActionErrors.set(receipt, request.onError);
            }
            this.rxStomp.publish({
                destination: request.destination,
                headers: {
                    'content-type': 'application/json;charset=UTF-8',
                    receipt: receipt,
                },
                body: JSON.stringify(request.body),
            });
        });
    }
    sendToStream(request) {
        var _a, _b, _c;
        const data = new FormData();
        let file = request.file;
        if (!(file instanceof File)) {
            file = StompX.dataUriToFile(file.uri, file.name);
        }
        data.append('file', file);
        (_a = request.properties) === null || _a === void 0 ? void 0 : _a.forEach((value, key) => {
            data.append(key, JSON.stringify(value));
        });
        (_c = (_b = request.progressListener) === null || _b === void 0 ? void 0 : _b.onStarted) === null || _c === void 0 ? void 0 : _c.call(_b);
        this.axios({
            method: 'post',
            url: request.stream,
            data: data,
            headers: { 'Content-Type': 'multipart/form-data', Grant: request.grant },
            onUploadProgress: (progressEvent) => {
                var _a, _b;
                (_b = (_a = request.progressListener) === null || _a === void 0 ? void 0 : _a.onProgress) === null || _b === void 0 ? void 0 : _b.call(_a, progressEvent.loaded / progressEvent.total);
            },
        })
            .then((response) => {
            var _a, _b, _c;
            (_b = (_a = request.progressListener) === null || _a === void 0 ? void 0 : _a.onCompleted) === null || _b === void 0 ? void 0 : _b.call(_a);
            (_c = request.onSuccess) === null || _c === void 0 ? void 0 : _c.call(request, response.data);
        })
            .catch((error) => {
            var _a, _b, _c;
            (_b = (_a = request.progressListener) === null || _a === void 0 ? void 0 : _a.onFailed) === null || _b === void 0 ? void 0 : _b.call(_a);
            (_c = request.onError) === null || _c === void 0 ? void 0 : _c.call(request, error);
        });
    }
    disconnect() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.topics.forEach((subscription) => {
                subscription.unsubscribe();
            });
            this.topics.clear();
            this.pendingActions.clear();
            this.pendingActionErrors.clear();
            this.pendingRelayErrors.clear();
            this.eventHandlers.clear();
            this.initialized = false;
            yield this.rxStomp.deactivate();
            this.rxStomp = new rx_stomp_1.RxStomp();
        });
    }
    guardConnected(action) {
        this.rxStomp.connected$.pipe((0, operators_1.take)(1)).subscribe(() => {
            action();
        });
    }
    static dataUriToFile(url, name) {
        var _a;
        const arr = url.split(','), mime = (_a = arr[0].match(/:(.*?);/)) === null || _a === void 0 ? void 0 : _a[1], bstr = atob(arr[1]);
        let n = bstr.length;
        const u8arr = new Uint8Array(n);
        while (n--) {
            u8arr[n] = bstr.charCodeAt(n);
        }
        return new File([u8arr], name, { type: mime });
    }
    static generateSubscriptionId() {
        return 'subscription-id-' + (0, uuid_1.v4)();
    }
    static generateReceipt() {
        return 'receipt-' + (0, uuid_1.v4)();
    }
}
exports.default = StompX;
//# sourceMappingURL=stompx.js.map