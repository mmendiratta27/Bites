"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChatKitty = void 0;
const tslib_1 = require("tslib");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const environment_1 = require("../environment/environment");
const stompx_1 = require("./stompx");
const channel_1 = require("./channel");
const chat_session_1 = require("./chat-session");
const current_user_1 = require("./current-user");
const event_1 = require("./event");
const file_1 = require("./file");
const message_1 = require("./message");
const pagination_1 = require("./pagination");
const reaction_1 = require("./reaction");
const read_receipt_1 = require("./read-receipt");
const result_1 = require("./result");
const thread_1 = require("./thread");
const user_1 = require("./user");
const user_blocked_record_1 = require("./user-blocked-record");
const user_session_1 = require("./user-session");
class ChatKitty {
    constructor(configuration) {
        this.configuration = configuration;
        this.currentUserSubject = new rxjs_1.BehaviorSubject(null);
        this.lostConnectionSubject = new rxjs_1.Subject();
        this.resumedConnectionSubject = new rxjs_1.Subject();
        this.chatSessions = new Map();
        this.messageMapper = new MessageMapper('');
        this.keyStrokesSubject = new rxjs_1.Subject();
        this.stompX = new stompx_1.default({
            isSecure: configuration.isSecure === undefined || configuration.isSecure,
            host: configuration.host || 'api.chatkitty.com',
            isDebug: !environment_1.environment.production,
        });
        this.keyStrokesSubject
            .asObservable()
            .pipe((0, operators_1.debounceTime)(150))
            .subscribe((request) => {
            let destination = '';
            const channel = request.channel;
            const thread = request.thread;
            if (channel) {
                destination = channel._actions.keystrokes;
            }
            if (thread) {
                destination = thread._actions.keystrokes;
            }
            this.stompX.sendAction({
                destination,
                body: {
                    keys: request.keys,
                },
            });
        });
    }
    static getInstance(apiKey) {
        let instance = ChatKitty._instances.get(apiKey);
        if (instance !== undefined) {
            return instance;
        }
        instance = new ChatKitty({ apiKey: apiKey });
        ChatKitty._instances.set(apiKey, instance);
        return instance;
    }
    static channelRelay(id) {
        return '/application/v1/channels/' + id + '.relay';
    }
    static userRelay(id) {
        return '/application/v1/users/' + id + '.relay';
    }
    startSession(request) {
        if (this.stompX.initialized) {
            throw new user_session_1.SessionActiveError();
        }
        return new Promise((resolve) => {
            this.stompX.connect({
                apiKey: this.configuration.apiKey,
                username: request.username,
                authParams: request.authParams,
                onSuccess: (user, writeFileGrant, readFileGrant) => {
                    this.stompX.listenToTopic({ topic: user._topics.self });
                    this.stompX.listenToTopic({ topic: user._topics.channels });
                    this.stompX.listenToTopic({ topic: user._topics.messages });
                    this.stompX.listenToTopic({ topic: user._topics.notifications });
                    this.stompX.listenToTopic({ topic: user._topics.contacts });
                    this.stompX.listenToTopic({ topic: user._topics.participants });
                    this.stompX.listenToTopic({ topic: user._topics.users });
                    this.stompX.listenToTopic({ topic: user._topics.reactions });
                    this.stompX.listenToTopic({ topic: user._topics.threads });
                    this.stompX.listenToTopic({ topic: user._topics.calls });
                    this.writeFileGrant = writeFileGrant;
                    this.messageMapper = new MessageMapper(readFileGrant);
                    resolve(new user_session_1.StartedSessionResult({ user: user }));
                },
                onConnected: (user) => {
                    this.currentUser = user;
                    this.currentUserSubject.next(user);
                },
                onConnectionLost: () => this.lostConnectionSubject.next(),
                onConnectionResumed: () => this.resumedConnectionSubject.next(),
                onError: (error) => {
                    resolve(new result_1.ChatKittyFailedResult(error));
                },
            });
        });
    }
    endSession() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.stompX.disconnect();
            this.currentUser = undefined;
            this.currentUserSubject.next(null);
        });
    }
    retrieveCurrentUser() {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        return new Promise((resolve) => {
            this.stompX.relayResource({
                destination: currentUser._relays.self,
                onSuccess: (user) => {
                    resolve(new current_user_1.RetrieveCurrentUserSuccessfulResult(user));
                },
                onError: (error) => {
                    resolve(new result_1.ChatKittyFailedResult(error));
                },
            });
        });
    }
    onCurrentUserChanged(onNextOrObserver) {
        const subscription = this.currentUserSubject.subscribe((user) => {
            if (typeof onNextOrObserver === 'function') {
                onNextOrObserver(user);
            }
            else {
                onNextOrObserver.onNext(user);
            }
        });
        return () => subscription.unsubscribe();
    }
    onCurrentUserOnline(onNextOrObserver) {
        const subscription = this.resumedConnectionSubject.subscribe(() => {
            if (typeof onNextOrObserver === 'function') {
                onNextOrObserver();
            }
            else {
                if (this.currentUser) {
                    onNextOrObserver.onNext(this.currentUser);
                }
            }
        });
        return () => subscription.unsubscribe();
    }
    onCurrentUserOffline(onNextOrObserver) {
        const subscription = this.lostConnectionSubject.subscribe(() => {
            if (typeof onNextOrObserver === 'function') {
                onNextOrObserver();
            }
            else {
                if (this.currentUser) {
                    onNextOrObserver.onNext(this.currentUser);
                }
            }
        });
        return () => subscription.unsubscribe();
    }
    updateCurrentUser(update) {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        return new Promise((resolve) => {
            this.stompX.sendAction({
                destination: currentUser._actions.update,
                body: update(currentUser),
                onSuccess: (user) => {
                    this.currentUserSubject.next(user);
                    resolve(new current_user_1.UpdatedCurrentUserResult(user));
                },
                onError: (error) => {
                    resolve(new result_1.ChatKittyFailedResult(error));
                },
            });
        });
    }
    updateCurrentUserDisplayPicture(request) {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        return new Promise((resolve) => {
            const file = request.file;
            if (file.uri) {
                this.stompX.sendToStream({
                    stream: currentUser._streams.displayPicture,
                    grant: this.writeFileGrant,
                    file: file,
                    onSuccess: (user) => {
                        resolve(new current_user_1.UpdatedCurrentUserDisplayPictureResult(user));
                    },
                    onError: (error) => {
                        resolve(new result_1.ChatKittyFailedResult(error));
                    },
                    progressListener: {
                        onStarted: () => { var _a, _b; return (_b = (_a = request.progressListener) === null || _a === void 0 ? void 0 : _a.onStarted) === null || _b === void 0 ? void 0 : _b.call(_a); },
                        onProgress: (progress) => { var _a; return (_a = request.progressListener) === null || _a === void 0 ? void 0 : _a.onProgress(progress); },
                        onCompleted: () => {
                            var _a;
                            return (_a = request.progressListener) === null || _a === void 0 ? void 0 : _a.onCompleted(file_1.ChatKittyUploadResult.COMPLETED);
                        },
                        onFailed: () => {
                            var _a;
                            return (_a = request.progressListener) === null || _a === void 0 ? void 0 : _a.onCompleted(file_1.ChatKittyUploadResult.FAILED);
                        },
                        onCancelled: () => {
                            var _a;
                            return (_a = request.progressListener) === null || _a === void 0 ? void 0 : _a.onCompleted(file_1.ChatKittyUploadResult.CANCELLED);
                        },
                    },
                });
            }
            else {
                this.stompX.sendAction({
                    destination: currentUser._actions.updateDisplayPicture,
                    body: file,
                    onSuccess: (user) => {
                        resolve(new current_user_1.UpdatedCurrentUserResult(user));
                    },
                    onError: (error) => {
                        resolve(new result_1.ChatKittyFailedResult(error));
                    },
                });
            }
        });
    }
    updateChannel(request) {
        return new Promise((resolve) => {
            this.stompX.sendAction({
                destination: request.channel._actions.update,
                body: request.channel,
                onSuccess: (channel) => {
                    resolve(new channel_1.UpdatedChannelResult(channel));
                },
                onError: (error) => {
                    resolve(new result_1.ChatKittyFailedResult(error));
                },
            });
        });
    }
    deleteChannel(request) {
        return new Promise((resolve) => {
            this.stompX.sendAction({
                destination: request.channel._actions.delete,
                body: {},
                onSuccess: () => {
                    resolve(new channel_1.DeletedChannelResult());
                },
                onError: (error) => {
                    resolve(new result_1.ChatKittyFailedResult(error));
                },
            });
        });
    }
    createChannel(request) {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        return new Promise((resolve) => {
            this.stompX.sendAction({
                destination: currentUser._actions.createChannel,
                events: [
                    'user.channel.created',
                    'user.channel.upserted',
                    'member.channel.upserted',
                ],
                body: request,
                onSuccess: (channel) => {
                    resolve(new channel_1.CreatedChannelResult(channel));
                },
                onError: (error) => {
                    resolve(new result_1.ChatKittyFailedResult(error));
                },
            });
        });
    }
    listChannels(request) {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        return new Promise((resolve) => {
            var _a, _b, _c, _d;
            const parameters = {};
            let relay = currentUser._relays.channels;
            if (isListChannelsRequest(request)) {
                if (((_a = request.filter) === null || _a === void 0 ? void 0 : _a.joined) === false) {
                    relay = currentUser._relays.joinableChannels;
                }
                if (((_b = request.filter) === null || _b === void 0 ? void 0 : _b.joined) === true) {
                    parameters.subscribable = true;
                }
                if ((_c = request.filter) === null || _c === void 0 ? void 0 : _c.unread) {
                    relay = currentUser._relays.unreadChannels;
                }
            }
            const name = (_d = request === null || request === void 0 ? void 0 : request.filter) === null || _d === void 0 ? void 0 : _d.name;
            if (name) {
                parameters.name = name;
            }
            pagination_1.ChatKittyPaginator.createInstance({
                stompX: this.stompX,
                relay: relay,
                contentName: 'channels',
                parameters: parameters,
            })
                .then((paginator) => resolve(new channel_1.ListChannelsSucceededResult(paginator)))
                .catch((error) => resolve(new result_1.ChatKittyFailedResult(error)));
        });
    }
    retrieveChannel(id) {
        return new Promise((resolve) => {
            this.stompX.relayResource({
                destination: ChatKitty.channelRelay(id),
                onSuccess: (channel) => {
                    resolve(new channel_1.RetrieveChannelSucceededResult(channel));
                },
                onError: (error) => {
                    resolve(new result_1.ChatKittyFailedResult(error));
                },
            });
        });
    }
    joinChannel(request) {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        const destination = request.channel._actions.join;
        if (!destination) {
            throw new channel_1.ChannelNotPubliclyJoinableError(request.channel);
        }
        return new Promise((resolve) => {
            this.stompX.sendAction({
                destination: destination,
                body: request,
                onSuccess: (channel) => {
                    resolve(new channel_1.JoinedChannelResult(channel));
                },
                onError: (error) => {
                    resolve(new result_1.ChatKittyFailedResult(error));
                },
            });
        });
    }
    leaveChannel(request) {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        const destination = request.channel._actions.leave;
        if (!destination) {
            throw new channel_1.NotAChannelMemberError(request.channel);
        }
        return new Promise((resolve) => {
            this.stompX.sendAction({
                destination: destination,
                body: {},
                onSuccess: (channel) => {
                    resolve(new channel_1.LeftChannelResult(channel));
                },
                onError: (error) => {
                    resolve(new result_1.ChatKittyFailedResult(error));
                },
            });
        });
    }
    addChannelModerator(request) {
        const destination = request.channel._actions.addModerator;
        if (!destination) {
            throw new channel_1.CannotAddModeratorToChannelError(request.channel);
        }
        return new Promise((resolve) => {
            this.stompX.sendAction({
                destination: destination,
                body: request.user,
                onSuccess: (channel) => {
                    resolve(new channel_1.AddedChannelModeratorResult(channel));
                },
                onError: (error) => {
                    resolve(new result_1.ChatKittyFailedResult(error));
                },
            });
        });
    }
    countUnreadChannels(request) {
        var _a;
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        const parameters = {
            unread: true,
        };
        if (isListChannelsUnreadRequest(request)) {
            parameters.type = (_a = request.filter) === null || _a === void 0 ? void 0 : _a.type;
        }
        return new Promise((resolve) => {
            this.stompX.relayResource({
                destination: currentUser._relays.channelsCount,
                parameters: parameters,
                onSuccess: (resource) => {
                    resolve(new result_1.CountSucceededResult(resource.count));
                },
                onError: (error) => {
                    resolve(new result_1.ChatKittyFailedResult(error));
                },
            });
        });
    }
    checkChannelUnread(request) {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        return new Promise((resolve) => {
            this.stompX.relayResource({
                destination: request.channel._relays.unread,
                onSuccess: (resource) => {
                    resolve(new channel_1.CheckChannelUnreadSucceededResult(resource.exists));
                },
                onError: (error) => {
                    resolve(new result_1.ChatKittyFailedResult(error));
                },
            });
        });
    }
    readChannel(request) {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        return new Promise((resolve) => {
            this.stompX.sendAction({
                destination: request.channel._actions.read,
                body: {},
                onSent: () => resolve(new channel_1.ReadChannelSucceededResult(request.channel)),
                onError: (error) => resolve(new result_1.ChatKittyFailedResult(error)),
            });
        });
    }
    muteChannel(request) {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        return new Promise((resolve) => {
            this.stompX.sendAction({
                destination: request.channel._actions.mute,
                body: {
                    state: 'ON',
                },
                onSuccess: (channel) => {
                    resolve(new channel_1.MutedChannelResult(channel));
                },
                onError: (error) => {
                    resolve(new result_1.ChatKittyFailedResult(error));
                },
            });
        });
    }
    unmuteChannel(request) {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        return new Promise((resolve) => {
            this.stompX.sendAction({
                destination: request.channel._actions.mute,
                body: {
                    state: 'OFF',
                },
                onSuccess: (channel) => {
                    resolve(new channel_1.UnmutedChannelResult(channel));
                },
                onError: (error) => {
                    resolve(new result_1.ChatKittyFailedResult(error));
                },
            });
        });
    }
    clearChannelHistory(request) {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        return new Promise((resolve) => {
            this.stompX.sendAction({
                destination: request.channel._actions.clearHistory,
                body: {},
                onSuccess: (channel) => resolve(new channel_1.ClearChannelHistorySucceededResult(channel)),
                onError: (error) => resolve(new result_1.ChatKittyFailedResult(error)),
            });
        });
    }
    hideChannel(request) {
        return new Promise((resolve) => {
            this.stompX.sendAction({
                destination: request.channel._actions.hide,
                body: {},
                onSuccess: (resource) => resolve(new channel_1.HideChannelSucceededResult(resource)),
                onError: (error) => resolve(new result_1.ChatKittyFailedResult(error)),
            });
        });
    }
    startChatSession(request) {
        const onMessageReceived = request.onMessageReceived;
        const onKeystrokesReceived = request.onKeystrokesReceived;
        const onParticipantEnteredChat = request.onParticipantEnteredChat;
        const onParticipantLeftChat = request.onParticipantLeftChat;
        const onTypingStarted = request.onTypingStarted;
        const onTypingStopped = request.onTypingStopped;
        const onParticipantPresenceChanged = request.onParticipantPresenceChanged;
        const onEventTriggered = request.onEventTriggered;
        const onMessageUpdated = request.onMessageUpdated;
        const onMessageDeleted = request.onMessageDeleted;
        const onChannelUpdated = request.onChannelUpdated;
        const onMessageRead = request.onMessageRead;
        const onMessageReactionAdded = request.onMessageReactionAdded;
        const onMessageReactionRemoved = request.onMessageReactionRemoved;
        const onThreadMessageReceived = request.onThreadMessageReceived;
        const onThreadKeystrokesReceived = request.onThreadKeystrokesReceived;
        const onThreadTypingStarted = request.onThreadTypingStarted;
        const onThreadTypingStopped = request.onThreadTypingStopped;
        let messageReceivedUnsubscribe;
        let keystrokesReceivedUnsubscribe;
        let participantEnteredChatUnsubscribe;
        let participantLeftChatUnsubscribe;
        let typingStartedUnsubscribe;
        let typingStoppedUnsubscribe;
        let participantPresenceChangedUnsubscribe;
        let eventTriggeredUnsubscribe;
        let messageUpdatedUnsubscribe;
        let messageDeletedUnsubscribe;
        let channelUpdatedUnsubscribe;
        let messageReadUnsubscribe;
        let messageReactionAddedUnsubscribe;
        let messageReactionRemovedUnsubscribe;
        let threadMessageReceivedUnsubscribe;
        let threadKeystrokesReceivedUnsubscribe;
        let threadTypingStartedUnsubscribe;
        let threadTypingStoppedUnsubscribe;
        if (onMessageReceived) {
            messageReceivedUnsubscribe = this.stompX.listenForEvent({
                topic: request.channel._topics.messages,
                event: 'channel.message.created',
                onSuccess: (message) => {
                    const destination = message._relays.parent;
                    if (destination) {
                        this.stompX.relayResource({
                            destination,
                            onSuccess: (parent) => {
                                onMessageReceived(this.messageMapper.map(message), this.messageMapper.map(parent));
                            },
                        });
                    }
                    else {
                        onMessageReceived(this.messageMapper.map(message));
                    }
                },
            });
        }
        if (onKeystrokesReceived) {
            keystrokesReceivedUnsubscribe = this.stompX.listenForEvent({
                topic: request.channel._topics.keystrokes,
                event: 'thread.keystrokes.created',
                onSuccess: (keystrokes) => {
                    onKeystrokesReceived(keystrokes);
                },
            });
        }
        if (onTypingStarted) {
            typingStartedUnsubscribe = this.stompX.listenForEvent({
                topic: request.channel._topics.typing,
                event: 'thread.typing.started',
                onSuccess: (user) => {
                    onTypingStarted(user);
                },
            });
        }
        if (onTypingStopped) {
            typingStoppedUnsubscribe = this.stompX.listenForEvent({
                topic: request.channel._topics.typing,
                event: 'thread.typing.stopped',
                onSuccess: (user) => {
                    onTypingStopped(user);
                },
            });
        }
        if (onParticipantEnteredChat) {
            participantEnteredChatUnsubscribe = this.stompX.listenForEvent({
                topic: request.channel._topics.participants,
                event: 'channel.participant.active',
                onSuccess: (user) => {
                    onParticipantEnteredChat(user);
                },
            });
        }
        if (onParticipantLeftChat) {
            participantLeftChatUnsubscribe = this.stompX.listenForEvent({
                topic: request.channel._topics.participants,
                event: 'channel.participant.inactive',
                onSuccess: (user) => {
                    onParticipantLeftChat(user);
                },
            });
        }
        if (onParticipantPresenceChanged) {
            participantPresenceChangedUnsubscribe = this.stompX.listenForEvent({
                topic: request.channel._topics.participants,
                event: 'participant.presence.changed',
                onSuccess: (user) => {
                    onParticipantPresenceChanged(user);
                },
            });
        }
        if (onMessageUpdated) {
            messageUpdatedUnsubscribe = this.stompX.listenForEvent({
                topic: request.channel._topics.messages,
                event: 'channel.message.updated',
                onSuccess: (message) => {
                    onMessageUpdated(message);
                },
            });
        }
        if (onMessageDeleted) {
            messageDeletedUnsubscribe = this.stompX.listenForEvent({
                topic: request.channel._topics.messages,
                event: 'channel.message.deleted',
                onSuccess: (message) => {
                    onMessageDeleted(message);
                },
            });
        }
        if (onEventTriggered) {
            eventTriggeredUnsubscribe = this.stompX.listenForEvent({
                topic: request.channel._topics.events,
                event: 'channel.event.triggered',
                onSuccess: (event) => {
                    onEventTriggered(event);
                },
            });
        }
        if (onChannelUpdated) {
            channelUpdatedUnsubscribe = this.stompX.listenForEvent({
                topic: request.channel._topics.self,
                event: 'channel.self.updated',
                onSuccess: (channel) => {
                    onChannelUpdated(channel);
                },
            });
        }
        if (onMessageRead) {
            messageReadUnsubscribe = this.stompX.listenForEvent({
                topic: request.channel._topics.readReceipts,
                event: 'message.read_receipt.created',
                onSuccess: (receipt) => {
                    this.stompX.relayResource({
                        destination: receipt._relays.message,
                        onSuccess: (message) => {
                            onMessageRead(message, receipt);
                        },
                    });
                },
            });
        }
        if (onMessageReactionAdded) {
            messageReactionAddedUnsubscribe = this.stompX.listenForEvent({
                topic: request.channel._topics.reactions,
                event: 'message.reaction.created',
                onSuccess: (reaction) => {
                    this.stompX.relayResource({
                        destination: reaction._relays.message,
                        onSuccess: (message) => {
                            onMessageReactionAdded(message, reaction);
                        },
                    });
                },
            });
        }
        if (onMessageReactionRemoved) {
            messageReactionRemovedUnsubscribe = this.stompX.listenForEvent({
                topic: request.channel._topics.reactions,
                event: 'message.reaction.removed',
                onSuccess: (reaction) => {
                    this.stompX.relayResource({
                        destination: reaction._relays.message,
                        onSuccess: (message) => {
                            onMessageReactionRemoved(message, reaction);
                        },
                    });
                },
            });
        }
        let end = () => {
            messageReactionRemovedUnsubscribe === null || messageReactionRemovedUnsubscribe === void 0 ? void 0 : messageReactionRemovedUnsubscribe();
            messageReactionAddedUnsubscribe === null || messageReactionAddedUnsubscribe === void 0 ? void 0 : messageReactionAddedUnsubscribe();
            messageReadUnsubscribe === null || messageReadUnsubscribe === void 0 ? void 0 : messageReadUnsubscribe();
            channelUpdatedUnsubscribe === null || channelUpdatedUnsubscribe === void 0 ? void 0 : channelUpdatedUnsubscribe();
            messageUpdatedUnsubscribe === null || messageUpdatedUnsubscribe === void 0 ? void 0 : messageUpdatedUnsubscribe();
            messageDeletedUnsubscribe === null || messageDeletedUnsubscribe === void 0 ? void 0 : messageDeletedUnsubscribe();
            eventTriggeredUnsubscribe === null || eventTriggeredUnsubscribe === void 0 ? void 0 : eventTriggeredUnsubscribe();
            participantPresenceChangedUnsubscribe === null || participantPresenceChangedUnsubscribe === void 0 ? void 0 : participantPresenceChangedUnsubscribe();
            participantLeftChatUnsubscribe === null || participantLeftChatUnsubscribe === void 0 ? void 0 : participantLeftChatUnsubscribe();
            participantEnteredChatUnsubscribe === null || participantEnteredChatUnsubscribe === void 0 ? void 0 : participantEnteredChatUnsubscribe();
            typingStoppedUnsubscribe === null || typingStoppedUnsubscribe === void 0 ? void 0 : typingStoppedUnsubscribe();
            typingStartedUnsubscribe === null || typingStartedUnsubscribe === void 0 ? void 0 : typingStartedUnsubscribe();
            keystrokesReceivedUnsubscribe === null || keystrokesReceivedUnsubscribe === void 0 ? void 0 : keystrokesReceivedUnsubscribe();
            messageReceivedUnsubscribe === null || messageReceivedUnsubscribe === void 0 ? void 0 : messageReceivedUnsubscribe();
            threadMessageReceivedUnsubscribe === null || threadMessageReceivedUnsubscribe === void 0 ? void 0 : threadMessageReceivedUnsubscribe();
            threadKeystrokesReceivedUnsubscribe === null || threadKeystrokesReceivedUnsubscribe === void 0 ? void 0 : threadKeystrokesReceivedUnsubscribe();
            threadTypingStartedUnsubscribe === null || threadTypingStartedUnsubscribe === void 0 ? void 0 : threadTypingStartedUnsubscribe();
            threadTypingStoppedUnsubscribe === null || threadTypingStoppedUnsubscribe === void 0 ? void 0 : threadTypingStoppedUnsubscribe();
        };
        const channelUnsubscribe = this.stompX.listenToTopic({
            topic: request.channel._topics.self,
            onSuccess: () => {
                const messagesUnsubscribe = this.stompX.listenToTopic({
                    topic: request.channel._topics.messages,
                });
                const keystrokesUnsubscribe = this.stompX.listenToTopic({
                    topic: request.channel._topics.keystrokes,
                });
                const typingUnsubscribe = this.stompX.listenToTopic({
                    topic: request.channel._topics.typing,
                });
                const participantsUnsubscribe = this.stompX.listenToTopic({
                    topic: request.channel._topics.participants,
                });
                const readReceiptsUnsubscribe = this.stompX.listenToTopic({
                    topic: request.channel._topics.readReceipts,
                });
                const reactionsUnsubscribe = this.stompX.listenToTopic({
                    topic: request.channel._topics.reactions,
                });
                const eventsUnsubscribe = this.stompX.listenToTopic({
                    topic: request.channel._topics.events,
                });
                const superEnd = end;
                end = () => {
                    superEnd();
                    eventsUnsubscribe === null || eventsUnsubscribe === void 0 ? void 0 : eventsUnsubscribe();
                    reactionsUnsubscribe === null || reactionsUnsubscribe === void 0 ? void 0 : reactionsUnsubscribe();
                    readReceiptsUnsubscribe === null || readReceiptsUnsubscribe === void 0 ? void 0 : readReceiptsUnsubscribe();
                    participantsUnsubscribe === null || participantsUnsubscribe === void 0 ? void 0 : participantsUnsubscribe();
                    typingUnsubscribe === null || typingUnsubscribe === void 0 ? void 0 : typingUnsubscribe();
                    keystrokesUnsubscribe === null || keystrokesUnsubscribe === void 0 ? void 0 : keystrokesUnsubscribe();
                    messagesUnsubscribe === null || messagesUnsubscribe === void 0 ? void 0 : messagesUnsubscribe();
                    channelUnsubscribe();
                    this.chatSessions.delete(request.channel.id);
                };
            },
        });
        let activeThread = null;
        const session = {
            channel: request.channel,
            thread: activeThread,
            end: () => end(),
            setThread: (thread) => {
                threadMessageReceivedUnsubscribe === null || threadMessageReceivedUnsubscribe === void 0 ? void 0 : threadMessageReceivedUnsubscribe();
                threadKeystrokesReceivedUnsubscribe === null || threadKeystrokesReceivedUnsubscribe === void 0 ? void 0 : threadKeystrokesReceivedUnsubscribe();
                threadTypingStartedUnsubscribe === null || threadTypingStartedUnsubscribe === void 0 ? void 0 : threadTypingStartedUnsubscribe();
                threadTypingStoppedUnsubscribe === null || threadTypingStoppedUnsubscribe === void 0 ? void 0 : threadTypingStoppedUnsubscribe();
                if (onThreadMessageReceived) {
                    threadMessageReceivedUnsubscribe =
                        this.stompX.listenForEvent({
                            topic: thread._topics.messages,
                            event: 'thread.message.created',
                            onSuccess: (message) => {
                                onThreadMessageReceived(thread, this.messageMapper.map(message));
                            },
                        });
                }
                if (onThreadKeystrokesReceived) {
                    threadKeystrokesReceivedUnsubscribe =
                        this.stompX.listenForEvent({
                            topic: thread._topics.keystrokes,
                            event: 'thread.keystrokes.created',
                            onSuccess: (keystrokes) => {
                                onThreadKeystrokesReceived(thread, keystrokes);
                            },
                        });
                }
                if (onThreadTypingStarted) {
                    threadTypingStartedUnsubscribe = this.stompX.listenForEvent({
                        topic: thread._topics.typing,
                        event: 'thread.typing.started',
                        onSuccess: (user) => {
                            onThreadTypingStarted(thread, user);
                        },
                    });
                }
                if (onThreadTypingStopped) {
                    threadTypingStoppedUnsubscribe = this.stompX.listenForEvent({
                        topic: thread._topics.typing,
                        event: 'thread.typing.stopped',
                        onSuccess: (user) => {
                            onThreadTypingStopped(thread, user);
                        },
                    });
                }
                activeThread = thread;
            },
        };
        this.chatSessions.set(request.channel.id, session);
        return new chat_session_1.StartedChatSessionResult(session);
    }
    sendMessage(request) {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        return new Promise((resolve) => {
            let destination = '';
            let stream = '';
            const sendChannelMessageRequest = request;
            if (sendChannelMessageRequest.channel !== undefined) {
                destination = sendChannelMessageRequest.channel._actions.message;
                stream = sendChannelMessageRequest.channel._streams.messages;
            }
            const sendMessageReplyRequest = request;
            if (sendMessageReplyRequest.message !== undefined) {
                destination = sendMessageReplyRequest.message._actions.reply;
                stream = sendMessageReplyRequest.message._streams.replies;
            }
            const sendThreadMessageRequest = request;
            if (sendThreadMessageRequest.thread !== undefined) {
                destination = sendThreadMessageRequest.thread._actions.message;
                stream = sendThreadMessageRequest.thread._streams.messages;
            }
            if (isSendChannelTextMessageRequest(request)) {
                this.stompX.sendAction({
                    destination: destination,
                    body: {
                        type: 'TEXT',
                        body: request.body,
                        groupTag: request.groupTag,
                        properties: request.properties,
                    },
                    onSuccess: (message) => {
                        resolve(new message_1.SentTextMessageResult(this.messageMapper.map(message)));
                    },
                    onError: (error) => {
                        resolve(new result_1.ChatKittyFailedResult(error));
                    },
                });
            }
            if (isSendChannelFileMessageRequest(request)) {
                const file = request.file;
                if (isCreateChatKittyExternalFileProperties(file)) {
                    this.stompX.sendAction({
                        destination: destination,
                        body: {
                            type: 'FILE',
                            file: file,
                            groupTag: request.groupTag,
                            properties: request.properties,
                        },
                        onSuccess: (message) => {
                            resolve(new message_1.SentFileMessageResult(this.messageMapper.map(message)));
                        },
                        onError: (error) => {
                            resolve(new result_1.ChatKittyFailedResult(error));
                        },
                    });
                }
                else {
                    const properties = new Map();
                    if (request.groupTag) {
                        properties.set('groupTag', request.groupTag);
                    }
                    if (request.properties) {
                        properties.set('properties', request.properties);
                    }
                    this.stompX.sendToStream({
                        stream: stream,
                        grant: this.writeFileGrant,
                        file: file,
                        properties: properties,
                        onSuccess: (message) => {
                            resolve(new message_1.SentFileMessageResult(this.messageMapper.map(message)));
                        },
                        onError: (error) => {
                            resolve(new result_1.ChatKittyFailedResult(error));
                        },
                        progressListener: {
                            onStarted: () => { var _a, _b; return (_b = (_a = request.progressListener) === null || _a === void 0 ? void 0 : _a.onStarted) === null || _b === void 0 ? void 0 : _b.call(_a); },
                            onProgress: (progress) => { var _a; return (_a = request.progressListener) === null || _a === void 0 ? void 0 : _a.onProgress(progress); },
                            onCompleted: () => {
                                var _a;
                                return (_a = request.progressListener) === null || _a === void 0 ? void 0 : _a.onCompleted(file_1.ChatKittyUploadResult.COMPLETED);
                            },
                            onFailed: () => {
                                var _a;
                                return (_a = request.progressListener) === null || _a === void 0 ? void 0 : _a.onCompleted(file_1.ChatKittyUploadResult.FAILED);
                            },
                            onCancelled: () => {
                                var _a;
                                return (_a = request.progressListener) === null || _a === void 0 ? void 0 : _a.onCompleted(file_1.ChatKittyUploadResult.CANCELLED);
                            },
                        },
                    });
                }
            }
        });
    }
    listMessages(request) {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        let relay = '';
        let parameters = undefined;
        if (isListUsersMessagesRequest(request)) {
            relay = currentUser._relays.messages;
            parameters = Object.assign({}, request.filter);
        }
        if (isListChannelMessagesRequest(request)) {
            relay = request.channel._relays.messages;
            parameters = Object.assign({}, request.filter);
        }
        if (isListMessageRepliesRequest(request)) {
            relay = request.message._relays.replies;
        }
        return new Promise((resolve) => {
            pagination_1.ChatKittyPaginator.createInstance({
                stompX: this.stompX,
                relay: relay,
                parameters: parameters,
                contentName: 'messages',
                mapper: (message) => this.messageMapper.map(message),
            })
                .then((paginator) => resolve(new message_1.ListMessagesSucceededResult(paginator)))
                .catch((error) => resolve(new result_1.ChatKittyFailedResult(error)));
        });
    }
    countUnreadMessages(request) {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        let relay = currentUser._relays.unreadMessagesCount;
        if (isCountUnreadMessagesRequest(request)) {
            relay = request.channel._relays.messagesCount;
        }
        return new Promise((resolve) => {
            this.stompX.relayResource({
                destination: relay,
                parameters: {
                    unread: true,
                },
                onSuccess: (resource) => {
                    resolve(new result_1.CountSucceededResult(resource.count));
                },
                onError: (error) => {
                    resolve(new result_1.ChatKittyFailedResult(error));
                },
            });
        });
    }
    triggerEvent(request) {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        return new Promise((resolve) => {
            this.stompX.sendAction({
                destination: request.channel._actions.triggerEvent,
                body: {
                    type: request.type,
                    properties: request.properties,
                },
                onSent: () => {
                    resolve(new event_1.TriggeredEventResult(request.channel));
                },
                onError: (error) => {
                    resolve(new result_1.ChatKittyFailedResult(error));
                },
            });
        });
    }
    readMessage(request) {
        return new Promise((resolve) => {
            this.stompX.sendAction({
                destination: request.message._actions.read,
                body: {},
                onSent: () => resolve(new message_1.ReadMessageSucceededResult(request.message)),
                onError: (error) => resolve(new result_1.ChatKittyFailedResult(error)),
            });
        });
    }
    retrieveLastReadMessage(request) {
        return new Promise((resolve) => {
            this.stompX.relayResource({
                destination: request.channel._relays.lastReadMessage,
                parameters: {
                    username: request.username,
                },
                onSuccess: (resource) => {
                    resolve(new message_1.RetrieveLastReadMessageSucceededResult(resource));
                },
                onError: (error) => {
                    resolve(new result_1.ChatKittyFailedResult(error));
                },
            });
        });
    }
    editMessage(request) {
        return new Promise((resolve) => {
            this.stompX.sendAction({
                destination: request.message._actions.edit,
                body: {
                    body: request.body,
                },
                onSuccess: (message) => resolve(new message_1.EditedMessageSucceededResult(message)),
                onError: (error) => resolve(new result_1.ChatKittyFailedResult(error)),
            });
        });
    }
    countMessageReplies(request) {
        return new Promise((resolve) => {
            this.stompX.relayResource({
                destination: request.message._relays.repliesCount,
                onSuccess: (resource) => {
                    resolve(new result_1.CountSucceededResult(resource.count));
                },
                onError: (error) => {
                    resolve(new result_1.ChatKittyFailedResult(error));
                },
            });
        });
    }
    retrieveMessageChannel(request) {
        return new Promise((resolve) => {
            this.stompX.relayResource({
                destination: request.message._relays.channel,
                onSuccess: (resource) => {
                    resolve(new message_1.RetrieveMessageChannelSucceededResult(resource));
                },
                onError: (error) => {
                    resolve(new result_1.ChatKittyFailedResult(error));
                },
            });
        });
    }
    retrieveMessageParent(request) {
        return new Promise((resolve) => {
            const destination = request.message._relays.parent;
            if (!destination) {
                throw new message_1.MessageNotAReplyError(request.message);
            }
            this.stompX.relayResource({
                destination,
                onSuccess: (resource) => {
                    resolve(new message_1.RetrieveMessageParentSucceededResult(resource));
                },
                onError: (error) => {
                    resolve(new result_1.ChatKittyFailedResult(error));
                },
            });
        });
    }
    createThread(request) {
        return new Promise((resolve) => {
            this.stompX.sendAction({
                destination: request.channel._actions.createThread,
                body: { name: request.name, properties: request.properties },
                onSuccess: (thread) => resolve(new thread_1.CreatedThreadResult(thread)),
                onError: (error) => resolve(new result_1.ChatKittyFailedResult(error)),
            });
        });
    }
    listThreads(request) {
        var _a, _b;
        const parameters = {};
        if (((_a = request.filter) === null || _a === void 0 ? void 0 : _a.includeMainThread) === false) {
            parameters.includeMainThread = false;
        }
        if (((_b = request.filter) === null || _b === void 0 ? void 0 : _b.standalone) === true) {
            parameters.standalone = true;
        }
        return new Promise((resolve) => {
            pagination_1.ChatKittyPaginator.createInstance({
                stompX: this.stompX,
                relay: request.channel._relays.threads,
                contentName: 'threads',
                parameters,
            })
                .then((paginator) => resolve(new thread_1.ListThreadsSucceededResult(paginator)))
                .catch((error) => resolve(new result_1.ChatKittyFailedResult(error)));
        });
    }
    listThreadChannel(request) {
        return new Promise((resolve) => {
            this.stompX.relayResource({
                destination: request.thread._relays.channel,
                onSuccess: (resource) => {
                    resolve(new thread_1.RetrieveThreadChannelSucceededResult(resource));
                },
                onError: (error) => {
                    resolve(new result_1.ChatKittyFailedResult(error));
                },
            });
        });
    }
    listThreadMessage(request) {
        return new Promise((resolve) => {
            this.stompX.relayResource({
                destination: request.thread._relays.message,
                onSuccess: (resource) => {
                    resolve(new thread_1.RetrieveThreadMessageSucceededResult(resource));
                },
                onError: (error) => {
                    resolve(new result_1.ChatKittyFailedResult(error));
                },
            });
        });
    }
    readThread(request) {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        return new Promise((resolve) => {
            this.stompX.sendAction({
                destination: request.thread._actions.read,
                body: {},
                onSent: () => resolve(new thread_1.ReadThreadSucceededResult(request.thread)),
                onError: (error) => resolve(new result_1.ChatKittyFailedResult(error)),
            });
        });
    }
    reactToMessage(request) {
        return new Promise((resolve) => {
            this.stompX.sendAction({
                destination: request.message._actions.react,
                body: { emoji: request.emoji },
                onSuccess: (reaction) => resolve(new reaction_1.ReactedToMessageResult(reaction)),
                onError: (error) => resolve(new result_1.ChatKittyFailedResult(error)),
            });
        });
    }
    listReactions(request) {
        return new Promise((resolve) => {
            pagination_1.ChatKittyPaginator.createInstance({
                stompX: this.stompX,
                relay: request.message._relays.reactions,
                contentName: 'reactions',
            })
                .then((paginator) => resolve(new reaction_1.ListReactionsSucceededResult(paginator)))
                .catch((error) => resolve(new result_1.ChatKittyFailedResult(error)));
        });
    }
    removeReaction(request) {
        return new Promise((resolve) => {
            this.stompX.sendAction({
                destination: request.message._actions.removeReaction,
                body: {
                    emoji: request.emoji,
                },
                onSuccess: (reaction) => resolve(new reaction_1.RemovedReactionResult(reaction)),
                onError: (error) => resolve(new result_1.ChatKittyFailedResult(error)),
            });
        });
    }
    deleteMessage(request) {
        return new Promise((resolve) => {
            this.stompX.sendAction({
                destination: request.message._actions.delete,
                body: {},
                onSuccess: (resource) => resolve(new message_1.DeleteMessageSucceededResult(resource)),
                onError: (error) => resolve(new result_1.ChatKittyFailedResult(error)),
            });
        });
    }
    sendKeystrokes(request) {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        this.keyStrokesSubject.next(request);
    }
    onNotificationReceived(onNextOrObserver) {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        const unsubscribe = this.stompX.listenForEvent({
            topic: currentUser._topics.notifications,
            event: 'user.notification.created',
            onSuccess: (notification) => {
                if (typeof onNextOrObserver === 'function') {
                    onNextOrObserver(notification);
                }
                else {
                    onNextOrObserver.onNext(notification);
                }
            },
        });
        return () => unsubscribe;
    }
    onChannelJoined(onNextOrObserver) {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        const unsubscribe = this.stompX.listenForEvent({
            topic: currentUser._topics.channels,
            event: 'user.channel.joined',
            onSuccess: (channel) => {
                if (typeof onNextOrObserver === 'function') {
                    onNextOrObserver(channel);
                }
                else {
                    onNextOrObserver.onNext(channel);
                }
            },
        });
        return () => unsubscribe;
    }
    onChannelHidden(onNextOrObserver) {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        const unsubscribe = this.stompX.listenForEvent({
            topic: currentUser._topics.channels,
            event: 'user.channel.hidden',
            onSuccess: (channel) => {
                if (typeof onNextOrObserver === 'function') {
                    onNextOrObserver(channel);
                }
                else {
                    onNextOrObserver.onNext(channel);
                }
            },
        });
        return () => unsubscribe;
    }
    onChannelUnhidden(onNextOrObserver) {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        const unsubscribe = this.stompX.listenForEvent({
            topic: currentUser._topics.channels,
            event: 'user.channel.unhidden',
            onSuccess: (channel) => {
                if (typeof onNextOrObserver === 'function') {
                    onNextOrObserver(channel);
                }
                else {
                    onNextOrObserver.onNext(channel);
                }
            },
        });
        return () => unsubscribe;
    }
    onChannelLeft(onNextOrObserver) {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        const unsubscribe = this.stompX.listenForEvent({
            topic: currentUser._topics.channels,
            event: 'user.channel.left',
            onSuccess: (channel) => {
                if (typeof onNextOrObserver === 'function') {
                    onNextOrObserver(channel);
                }
                else {
                    onNextOrObserver.onNext(channel);
                }
            },
        });
        return () => unsubscribe;
    }
    onChannelUpdated(onNextOrObserver) {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        const unsubscribe = this.stompX.listenForEvent({
            topic: currentUser._topics.channels,
            event: 'user.channel.updated',
            onSuccess: (channel) => {
                if (typeof onNextOrObserver === 'function') {
                    onNextOrObserver(channel);
                }
                else {
                    onNextOrObserver.onNext(channel);
                }
            },
        });
        return () => unsubscribe;
    }
    listChannelMembers(request) {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        return new Promise((resolve) => {
            pagination_1.ChatKittyPaginator.createInstance({
                stompX: this.stompX,
                relay: request.channel._relays.members,
                contentName: 'users',
                parameters: Object.assign({}, request.filter),
            })
                .then((paginator) => resolve(new user_1.ListUsersSucceededResult(paginator)))
                .catch((error) => resolve(new result_1.ChatKittyFailedResult(error)));
        });
    }
    listReadReceipts(request) {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        return new Promise((resolve) => {
            pagination_1.ChatKittyPaginator.createInstance({
                stompX: this.stompX,
                relay: request.message._relays.readReceipts,
                contentName: 'receipts',
            })
                .then((paginator) => resolve(new read_receipt_1.ListReadReceiptsSucceededResult(paginator)))
                .catch((error) => resolve(new result_1.ChatKittyFailedResult(error)));
        });
    }
    listUsers(request) {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        return new Promise((resolve) => {
            let parameters = undefined;
            if (isListUsersRequest(request)) {
                parameters = Object.assign({}, request.filter);
            }
            pagination_1.ChatKittyPaginator.createInstance({
                stompX: this.stompX,
                relay: currentUser._relays.contacts,
                contentName: 'users',
                parameters: parameters,
            })
                .then((paginator) => resolve(new user_1.ListUsersSucceededResult(paginator)))
                .catch((error) => resolve(new result_1.ChatKittyFailedResult(error)));
        });
    }
    listUsersCount(request) {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        return new Promise((resolve) => {
            let parameters = undefined;
            if (isListUsersRequest(request)) {
                parameters = Object.assign({}, request.filter);
            }
            this.stompX.relayResource({
                destination: currentUser._relays.contactsCount,
                parameters: parameters,
                onSuccess: (resource) => {
                    resolve(new result_1.CountSucceededResult(resource.count));
                },
                onError: (error) => resolve(new result_1.ChatKittyFailedResult(error)),
            });
        });
    }
    onUserPresenceChanged(onNextOrObserver) {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        const unsubscribe = this.stompX.listenForEvent({
            topic: currentUser._topics.contacts,
            event: 'contact.presence.changed',
            onSuccess: (user) => {
                if (typeof onNextOrObserver === 'function') {
                    onNextOrObserver(user);
                }
                else {
                    onNextOrObserver.onNext(user);
                }
            },
        });
        return () => unsubscribe;
    }
    inviteUser(request) {
        const destination = request.channel._actions.invite;
        if (!destination) {
            throw new channel_1.ChannelNotInvitableError(request.channel);
        }
        return new Promise((resolve) => {
            this.stompX.sendAction({
                destination: destination,
                body: {
                    user: request.user,
                },
                onSuccess: (resource) => {
                    resolve(new channel_1.InvitedUserResult(resource));
                },
                onError: (error) => resolve(new result_1.ChatKittyFailedResult(error)),
            });
        });
    }
    onParticipantStartedTyping(onNextOrObserver) {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        const unsubscribe = this.stompX.listenForEvent({
            topic: currentUser._topics.participants,
            event: 'participant.typing.started',
            onSuccess: (participant) => {
                if (typeof onNextOrObserver === 'function') {
                    onNextOrObserver(participant);
                }
                else {
                    onNextOrObserver.onNext(participant);
                }
            },
        });
        return () => unsubscribe;
    }
    onParticipantStoppedTyping(onNextOrObserver) {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        const unsubscribe = this.stompX.listenForEvent({
            topic: currentUser._topics.participants,
            event: 'participant.typing.stopped',
            onSuccess: (participant) => {
                if (typeof onNextOrObserver === 'function') {
                    onNextOrObserver(participant);
                }
                else {
                    onNextOrObserver.onNext(participant);
                }
            },
        });
        return () => unsubscribe;
    }
    retrieveUser(param) {
        return new Promise((resolve) => {
            this.stompX.relayResource({
                destination: ChatKitty.userRelay(param),
                onSuccess: (user) => {
                    resolve(new user_1.ListUserSucceededResult(user));
                },
            });
        });
    }
    checkUserIsChannelMember(request) {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        return new Promise((resolve) => {
            this.stompX.relayResource({
                destination: request.user._relays.channelMember,
                parameters: {
                    channelId: request.channel.id,
                },
                onSuccess: (resource) => {
                    resolve(new user_1.CheckUserIsChannelMemberSucceededResult(resource.exists));
                },
                onError: (error) => {
                    resolve(new result_1.ChatKittyFailedResult(error));
                },
            });
        });
    }
    blockUser(request) {
        return new Promise((resolve) => {
            this.stompX.sendAction({
                destination: `/application/v1/users/${request.user.id}.block`,
                body: {},
                onSuccess: (resource) => {
                    resolve(new user_1.BlockUserSucceededResult(resource));
                },
                onError: (error) => resolve(new result_1.ChatKittyFailedResult(error)),
            });
        });
    }
    listUserBlockedRecords() {
        const currentUser = this.currentUser;
        if (!currentUser) {
            throw new user_session_1.NoActiveSessionError();
        }
        return new Promise((resolve) => {
            pagination_1.ChatKittyPaginator.createInstance({
                stompX: this.stompX,
                relay: currentUser._relays.userBlockedRecords,
                contentName: 'items',
            })
                .then((paginator) => resolve(new user_blocked_record_1.ListUserBlockedRecordsSucceededResult(paginator)))
                .catch((error) => resolve(new result_1.ChatKittyFailedResult(error)));
        });
    }
    deleteUserBlockedRecord(request) {
        return new Promise((resolve) => {
            this.stompX.sendAction({
                destination: request.item._actions.delete,
                body: {},
                onSuccess: (resource) => resolve(new user_blocked_record_1.DeleteUserBlockedRecordSucceededResult(resource)),
                onError: (error) => resolve(new result_1.ChatKittyFailedResult(error)),
            });
        });
    }
}
exports.ChatKitty = ChatKitty;
ChatKitty._instances = new Map();
class MessageMapper {
    constructor(grant) {
        this.readFileGrant = grant;
    }
    map(message) {
        if ((0, message_1.isFileMessage)(message)) {
            return Object.assign(Object.assign({}, message), { file: Object.assign(Object.assign({}, message.file), { url: message.file.url + `?grant=${this.readFileGrant}` }) });
        }
        else {
            return Object.assign({}, message);
        }
    }
}
function isListChannelsRequest(param) {
    const request = param;
    return (request === null || request === void 0 ? void 0 : request.filter) !== undefined;
}
function isListUsersRequest(param) {
    const request = param;
    return (request === null || request === void 0 ? void 0 : request.filter) !== undefined;
}
function isListChannelsUnreadRequest(param) {
    const request = param;
    return (request === null || request === void 0 ? void 0 : request.filter) !== undefined;
}
function isCountUnreadMessagesRequest(param) {
    const request = param;
    return (request === null || request === void 0 ? void 0 : request.channel) !== undefined;
}
function isSendChannelTextMessageRequest(request) {
    return request.body !== undefined;
}
function isSendChannelFileMessageRequest(request) {
    return request.file !== undefined;
}
function isListUsersMessagesRequest(request) {
    return (request.channel === undefined &&
        request.message === undefined);
}
function isListChannelMessagesRequest(request) {
    return request.channel !== undefined;
}
function isListMessageRepliesRequest(request) {
    return request.message !== undefined;
}
function isCreateChatKittyExternalFileProperties(result) {
    return (result.url !== undefined &&
        result.name !== undefined &&
        result.size !== undefined);
}
exports.default = ChatKitty;
//# sourceMappingURL=chatkitty.js.map